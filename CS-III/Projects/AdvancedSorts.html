<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Dylan's Digital Portfolio</title>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&family=Silkscreen&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="apa2.css">
  </head>

  <body>
    <header>
      <h1>Dylan Pettijohn's Digital Portfolio</h1>
      <h2>Student at Allen High School</h2>
      <a class="headerLink" href="../../index.html">About Me</a>
      <a class="headerLink" href="../education.html">Education and Projects</a>
      <a class="headerLink" href="../articles.html">Articles</a>
      <a class="headerLink" href="./../Projects/ISP/isp.html">ISP</a>   
    </header>

    <h3><u>Advanced Sorts</u></h3>

    <p class="APAHead">Dylan Pettijohn<br>Allen High School<br>Computer Science II<br>Mr. Ben-Yaakov<br>September 9, 2022</p><br>
    <h4>Merge Sort</h4>
    <p>The Merge Sort is a general-purpose, divide and conquer style sorting algorithm. It recursively divides the array into equal halves, then recombines them to be sorted. For example, with the following array of integers, [3,5,16,32,2,4,0,71]. First it splits the array in two, creating [3,5,16,32] and [2,4,0,71]. It will continute dividing in half until each array only contains one element. Then it joins them back together in groups, combining until it's back in one array.
    </p>

    <h4>Quicksort</h4>
    <p>The QuickSort algorithm is another divide and conquer style sort. It takes the array of numbers and selects a pivot point, oftentimes the last element in the array. This element will be our partition. The partition will split the lower numbers below it and higher numbers above it. It will then call itself again and repeat the process until each array contains only one element. Finally, it will recombine all the arrays to output a sorted array.
    </p>
    <h4>Heap sort</h4>
    <p>HeapSort utilizes binary trees called a heap. Binary trees have the ability to find parents and children of any particular node. The largest or smallest element should be the root node. All the children following should be smaller or larger respectively, as well as be ordered. The algorithm begins at the top of the tree, then recursively works down the tree swapping elements that are out of place. </p>

    <h4>Time Complexity Comparison</h4>

    <table>
      <tr>
	<th>Merge Sort</th>
	<th>QuickSort</th>
	<th>Heap Sort</th>
      </tr>
      <tr>
	<td>O(n*Log n)</td>
	<td>O(n*Log n)</td>
	<td>O(n*Log n)</td> 
      </tr>
      <tr>
	<td>O(n*Log n)</td>
	<td>O(n*Log n)</td>
	<td>O(n*Log n)</td> 
      </tr>
      <tr>
	<td>O(n*Log n)</td>
	<td>O(n^2)</td>
	<td>O(n*Log n)</td> 
      </tr>
    </table>    
    <p>The merge and heap sorting algorithms both have a uniform time complexity. This means it will take the same amount of time no matter how the elements are originally ordered. Quick Sort has a different worst case time complexity because it can skip some steps if elements are already sorted.</p>


    <h4>Space Complexity Comparison</h4>
    <table>
      <tr>
	<th>Merge Sort</th>
	<th>QuickSort</th>
	<th>Heap Sort</th> 
      </tr>
      <tr>
	<th>O(n)</th>
	<th>O(Log n)</th>
	<th>O(1)</th> 
      </tr>
    </table>
    <p>Merge sort has the largest space complexity, because it creates so many extra arrays. QuickSort has the next largest because it also creates arrays and splits off from them. It partitions them which means it rearranges them instead of merging them. However, in the worst case scenario it will cost the same as merge sort, as it would have to save the pivot element for every partition. Heap Sort is an in-place algorithm so it has a space complexity of O(1). That means the algorithm doesn't create any extra elements or arrays. It instead rearranges elements inside of the original array.</p>
  </body>
  </html>
